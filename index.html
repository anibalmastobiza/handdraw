<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HandDraw - Hand tracking drawing (MediaPipe)</title>
  <style>
    :root { --bg:#0b1020; --ink:#00c2ff; --panel:#11172a; --muted:#7f8ca3; --ok:#20c997; --warn:#f59f00; --err:#fa5252; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: #eaf2ff; font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }
    header { padding: 12px 16px; background: var(--panel); border-bottom: 1px solid #1d2540; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    header h1 { font-size: 16px; margin: 0 8px 0 0; font-weight: 600; }
    .btn { appearance: none; border: 1px solid #2b345a; background: #1a2140; color:#eaf2ff; padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight:600; }
    .btn[disabled] { opacity: .5; cursor: not-allowed; }
    .toolbar { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    label { color: var(--muted); font-size: 13px; }
    input[type="color"] { width: 34px; height: 34px; border: none; background: transparent; padding: 0; border-radius: 6px; box-shadow: 0 0 0 1px #2b345a inset; }
    input[type="range"] { accent-color: var(--ink); }
    .wrap { position: relative; width: min(96vw, 1200px); margin: 14px auto; }
    video, canvas { width: 100%; height: auto; display: block; border-radius: 16px; }
    .mirror { transform: scaleX(-1); }
    #video { position: relative; z-index: 0; background: #000; }
    #overlay { position: absolute; left: 0; top: 0; z-index: 2; pointer-events: none; }
    #draw { position: absolute; left: 0; top: 0; z-index: 1; pointer-events: none; }
    footer { text-align: center; color: var(--muted); font-size: 12px; padding: 10px; }
    .pill { padding: 4px 8px; border-radius: 999px; background: #0e1530; border:1px solid #24305a; }

    .notice { margin: 12px auto; width: min(96vw, 1200px); background:#121b34; border:1px solid #263056; border-radius:12px; padding:12px 14px; }
    .badge { font-size: 12px; padding: 2px 8px; border-radius: 999px; border: 1px solid; }
    .ok { color:#c8fff1; border-color: #174; background: #103a34; }
    .warn { color:#fff1cc; border-color: #5a460e; background: #3d2f09; }
    .err { color:#ffe3e3; border-color: #5a1414; background: #3a0f0f; }
    details { margin-top: 8px; }
    summary { cursor: pointer; color: #c7d2fe; }
    ul.testlist { list-style: none; padding-left: 0; }
    ul.testlist li { margin: 6px 0; display: flex; align-items: center; gap: 8px; }
    code.k { background:#0e1530; border:1px solid #24305a; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <header>
    <h1>✍️ HandDraw</h1>
    <div class="toolbar">
      <button id="startBtn" class="btn">Start camera</button>
      <button id="stopBtn" class="btn" disabled>Stop</button>
      <button id="clearBtn" class="btn">Clear</button>
      <button id="saveBtn" class="btn">Save PNG (strokes only)</button>
      <label>Color <input id="color" type="color" value="#00c2ff" /></label>
      <label>Thickness <input id="thickness" type="range" min="2" max="24" value="6" /></label>
      <label style="margin-left:8px;display:flex;align-items:center;gap:6px">
        <input id="includeOverlay" type="checkbox" checked /> Include overlay
      </label>
      <button id="saveCompositeBtn" class="btn" title="Export video + strokes (and overlay if checked)">Save composition (video+strokes)</button>
      <button id="mouseModeBtn" class="btn" title="Try without camera">Mouse mode (test)</button>
      <span class="pill">Gesture: thumb–index pinch = draw · release = stop</span>
    </div>
  </header>

  <div class="notice" id="envBanner" hidden>
    <div id="envMsg" style="margin-top:6px"></div>
    <details>
      <summary>Environment checks & tests</summary>
      <ul class="testlist" id="tests"></ul>
      <div style="margin-top:8px; font-size:13px; color:var(--muted)">
        Tips: use <code class="k">https://</code> or <code class="k">http://localhost</code>. If embedded in an <em>iframe</em> (e.g., a notebook), it must include <code class="k">allow="camera; microphone"</code>. Manually grant camera permission in your browser.
      </div>
    </details>
  </div>

  <div class="wrap">
    <video id="video" class="mirror" autoplay playsinline muted></video>
    <canvas id="draw" class="mirror"></canvas>
    <canvas id="overlay" class="mirror"></canvas>
  </div>

  <footer>
    Requirements: secure context (HTTPS) or <code>localhost</code>. Use thumb+index pinch to draw. You can also test the pipeline with <strong>Mouse mode</strong> without a camera.
  </footer>

  <script type="module">
    // --- Import MediaPipe Tasks Vision ---
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

    // --- UI refs ---
    const video = document.getElementById('video');
    const draw = document.getElementById('draw');
    const overlay = document.getElementById('overlay');
    const ctxDraw = draw.getContext('2d');
    const ctxOverlay = overlay.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const clearBtn = document.getElementById('clearBtn');
    const saveBtn = document.getElementById('saveBtn');
    const saveCompositeBtn = document.getElementById('saveCompositeBtn');
    const includeOverlayEl = document.getElementById('includeOverlay');
    const colorEl = document.getElementById('color');
    const thickEl = document.getElementById('thickness');
    const mouseModeBtn = document.getElementById('mouseModeBtn');
    const envBanner = document.getElementById('envBanner');
    const envMsg = document.getElementById('envMsg');
    const testsUl = document.getElementById('tests');

    // --- State ---
    let handLandmarker = null;
    let stream = null;
    let running = false;
    let lastVideoTime = -1;
    const lastPoint = { Left: null, Right: null };
    const drawing = { Left: false, Right: false };
    let mouseMode = false;

    // --- Utils ---
    function isSecureOrLocalhost() {
      return window.isSecureContext || /^localhost$|^127\.|^\[::1\]/.test(location.hostname);
    }

    function showBanner(kind, html) {
      envBanner.hidden = false;
      const label = kind === 'ok' ? '<span class="badge ok">OK</span>' : kind === 'warn' ? '<span class="badge warn">Warning</span>' : '<span class="badge err">Error</span>';
      envMsg.innerHTML = label + ' ' + html;
    }

    function addTest(name, passed, note = '') {
      const li = document.createElement('li');
      const cls = passed ? 'ok' : 'err';
      li.innerHTML = `<span class="badge ${cls}">${passed ? 'PASS' : 'FAIL'}</span> <strong>${name}</strong> <span style="color:var(--muted);font-size:13px">${note}</span>`;
      testsUl.appendChild(li);
    }

    function resizeCanvases() {
      const rect = video.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      for (const c of [draw, overlay]) {
        c.width = Math.max(2, Math.floor(rect.width * dpr));
        c.height = Math.max(2, Math.floor(rect.height * dpr));
        c.style.width = rect.width + 'px';
        c.style.height = rect.height + 'px';
      }
      ctxDraw.lineCap = 'round';
      ctxDraw.lineJoin = 'round';
    }

    function savePNG() {
      const link = document.createElement('a');
      link.download = 'handdraw.png';
      link.href = draw.toDataURL('image/png');
      link.click();
    }

    function saveComposite() {
      // Export composition: mirrored video + strokes (+ overlay optional)
      if (!video.videoWidth || !video.videoHeight) { showBanner('warn','Video is not ready to export. Start the camera first.'); return; }
      const w = overlay.width, h = overlay.height;
      const off = document.createElement('canvas');
      off.width = w; off.height = h;
      const octx = off.getContext('2d');

      // 1) Draw mirrored video
      try {
        octx.save();
        octx.scale(-1, 1);
        octx.drawImage(video, -w, 0, w, h);
        octx.restore();
      } catch (e) {
        showBanner('err', 'Unable to draw the video frame to canvas: ' + String(e));
        return;
      }

      // 2) Draw strokes (mirrored)
      octx.save();
      octx.scale(-1, 1);
      octx.drawImage(draw, -w, 0, w, h);
      octx.restore();

      // 3) Optional overlay
      if (includeOverlayEl.checked) {
        octx.save();
        octx.scale(-1, 1);
        octx.drawImage(overlay, -w, 0, w, h);
        octx.restore();
      }

      // 4) Download as JPEG
      const link = document.createElement('a');
      link.download = 'handdraw_composite.jpg';
      link.href = off.toDataURL('image/jpeg', 0.92);
      link.click();
    }

    function px(lm, w, h) { return { x: lm.x * w, y: lm.y * h, z: lm.z }; }

    function isPinching(landmarks, w, h, handKey) {
      const p4 = px(landmarks[4], w, h);
      const p8 = px(landmarks[8], w, h);
      const dx = p4.x - p8.x, dy = p4.y - p8.y;
      const dist = Math.hypot(dx, dy);
      const diag = Math.hypot(w, h);
      const onThresh = 0.035 * diag; // engage
      const offThresh = 0.055 * diag; // disengage
      if (!drawing[handKey] && dist < onThresh) drawing[handKey] = true;
      else if (drawing[handKey] && dist > offThresh) drawing[handKey] = false;
      return drawing[handKey];
    }

    function drawOverlay(results) {
      ctxOverlay.clearRect(0, 0, overlay.width, overlay.height);
      const w = overlay.width, h = overlay.height;
      ctxOverlay.globalAlpha = 0.9;
      ctxOverlay.lineWidth = 2;
      for (let i = 0; i < results.landmarks.length; i++) {
        const lms = results.landmarks[i];
        const tips = [0,4,8,12,16,20];
        for (const idx of tips) {
          const p = px(lms[idx], w, h);
          ctxOverlay.beginPath();
          ctxOverlay.arc(p.x, p.y, 4, 0, Math.PI*2);
          ctxOverlay.strokeStyle = 'rgba(0,194,255,0.8)';
          ctxOverlay.stroke();
        }
      }
    }

    function drawStroke(handKey, point) {
      const thickness = Number(thickEl.value);
      ctxDraw.strokeStyle = colorEl.value;
      ctxDraw.lineWidth = thickness;
      const lp = lastPoint[handKey];
      if (!lp) { lastPoint[handKey] = point; return; }
      ctxDraw.beginPath();
      ctxDraw.moveTo(lp.x, lp.y);
      ctxDraw.lineTo(point.x, point.y);
      ctxDraw.stroke();
      lastPoint[handKey] = point;
    }

    function clearTraces() { lastPoint.Left = lastPoint.Right = null; }

    async function waitForVideoReady() {
      let tries = 0;
      while ((video.videoWidth === 0 || video.videoHeight === 0) && tries < 50) {
        await new Promise(r => setTimeout(r, 50));
        tries++;
      }
    }

    async function start() {
      if (running || mouseMode) return;

      // Pre-checks: secure context, APIs, iframe restrictions
      const secure = isSecureOrLocalhost();
      addTest('Secure context or localhost', secure, location.protocol + '//' + location.host);
      if (!secure) {
        showBanner('err', 'Camera access requires a secure context. Open this page via <code class="k">https://</code> or <code class="k">http://localhost</code>.');
        return;
      }

      if (!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)) {
        addTest('mediaDevices.getUserMedia API', false, 'Unavailable');
        showBanner('err', 'Your browser does not expose <code class="k">navigator.mediaDevices.getUserMedia</code>. Please update your browser.');
        return;
      } else {
        addTest('mediaDevices.getUserMedia API', true);
      }

      const inIframe = window.top !== window.self;
      addTest('Embedded in an iframe', inIframe !== false, inIframe ? 'Yes' : 'No');
      if (inIframe) {
        showBanner('warn', 'This page appears inside an <em>iframe</em>. Ensure the frame includes <code class="k">allow="camera; microphone"</code> or the camera may be blocked.');
      }

      let permNote = 'Not supported';
      try {
        if (navigator.permissions?.query) {
          const st = await navigator.permissions.query({ name: 'camera' });
          permNote = st.state;
          addTest('Camera permission (Permissions API)', st.state === 'granted' || st.state === 'prompt', 'state=' + st.state);
          if (st.state === 'denied') {
            showBanner('err', 'Camera permission DENIED. Open your site settings and enable camera access.');
            return;
          }
        } else {
          addTest('Camera permission (Permissions API)', true, permNote);
        }
      } catch (e) {
        addTest('Camera permission (Permissions API)', false, String(e));
      }

      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        addTest('getUserMedia() returns stream', true);
      } catch (err) {
        addTest('getUserMedia() returns stream', false, err && err.name ? err.name : String(err));
        if (err && (err.name === 'NotAllowedError' || err.name === 'SecurityError')) {
          const msg = inIframe
            ? 'Camera blocked by <em>iframe</em> policies or permissions. Add <code class="k">allow="camera; microphone"</code> to the frame.'
            : 'Permission denied or site policy. Accept the permission prompt and ensure the site is served over HTTPS.';
          showBanner('err', msg);
        } else if (err && err.name === 'NotFoundError') {
          showBanner('err', 'No camera found. Connect a device or enable a virtual camera.');
        } else if (err && err.name === 'OverconstrainedError') {
          showBanner('err', 'Requested resolution cannot be satisfied. Try removing constraints.');
        } else {
          showBanner('err', 'Failed to start camera: ' + (err && err.message ? err.message : String(err)));
        }
        return;
      }

      video.srcObject = stream;
      try { await video.play(); } catch {}
      await waitForVideoReady();
      resizeCanvases();

      if (!handLandmarker) {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: 'GPU'
          },
          runningMode: 'VIDEO',
          numHands: 2,
          minHandDetectionConfidence: 0.5,
          minTrackingConfidence: 0.3,
          minHandPresenceConfidence: 0.5,
        });
      }

      running = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      window.addEventListener('resize', resizeCanvases);
      loop();
    }

    function stop() {
      running = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      window.removeEventListener('resize', resizeCanvases);
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      clearTraces();
      drawing.Left = drawing.Right = false;
      ctxOverlay.clearRect(0, 0, overlay.width, overlay.height);
    }

    function loop() {
      if (!running) return;
      if (video.currentTime !== lastVideoTime) {
        const now = performance.now();
        const results = handLandmarker.detectForVideo(video, now);
        lastVideoTime = video.currentTime;
        if (results?.landmarks?.length) {
          const w = overlay.width, h = overlay.height;
          drawOverlay(results);
          for (let i = 0; i < results.landmarks.length; i++) {
            const handKey = (results.handednesses && results.handednesses[i] && results.handednesses[i][0]) ? results.handednesses[i][0].categoryName : (i === 0 ? 'Left' : 'Right');
            const lms = results.landmarks[i];
            const pen = px(lms[8], w, h);
            const pinch = isPinching(lms, w, h, handKey);
            if (pinch) drawStroke(handKey, pen); else lastPoint[handKey] = null;
          }
        } else {
          ctxOverlay.clearRect(0, 0, overlay.width, overlay.height);
          clearTraces();
        }
      }
      requestAnimationFrame(loop);
    }

    // --- Mouse mode (no camera) ---
    function enableMouseMode(enable) {
      mouseMode = enable;
      if (enable) {
        stop();
        startBtn.disabled = true;
        stopBtn.disabled = true;
        overlay.style.pointerEvents = 'auto';
        ctxOverlay.clearRect(0, 0, overlay.width, overlay.height);
        showBanner('ok', 'Mouse mode ENABLED. Hold left mouse button to draw.');
      } else {
        overlay.style.pointerEvents = 'none';
        envBanner.hidden = true;
      }
    }

    let mouseDown = false;
    overlay.addEventListener('mousedown', (e) => {
      if (!mouseMode) return;
      const rect = overlay.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      mouseDown = true;
      lastPoint.Left = { x: (e.clientX - rect.left) * dpr, y: (e.clientY - rect.top) * dpr };
    });
    overlay.addEventListener('mousemove', (e) => {
      if (!mouseMode || !mouseDown) return;
      const rect = overlay.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const p = { x: (e.clientX - rect.left) * dpr, y: (e.clientY - rect.top) * dpr };
      drawStroke('Left', p);
    });
    overlay.addEventListener('mouseup', () => { if (mouseMode) { mouseDown = false; lastPoint.Left = null; } });
    overlay.addEventListener('mouseleave', () => { if (mouseMode) { mouseDown = false; lastPoint.Left = null; } });

    // --- UI events ---
    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
    clearBtn.addEventListener('click', () => ctxDraw.clearRect(0, 0, draw.width, draw.height));
    saveBtn.addEventListener('click', savePNG);
    saveCompositeBtn.addEventListener('click', saveComposite);
    mouseModeBtn.addEventListener('click', () => enableMouseMode(!mouseMode));

    // --- Automatic environment tests ---
    (async function runEnvTests(){
      testsUl.innerHTML = '';
      addTest('isSecureContext', isSecureOrLocalhost(), String(isSecureOrLocalhost()));
      addTest('Permissions API supported', !!(navigator.permissions?.query), navigator.permissions?.query ? 'yes' : 'no');
      addTest('mediaDevices present', !!navigator.mediaDevices, navigator.mediaDevices ? 'yes' : 'no');
      try {
        const devs = await navigator.mediaDevices?.enumerateDevices?.();
        const cams = (devs || []).filter(d => d.kind === 'videoinput');
        addTest('enumerateDevices() videoinput', cams.length > 0, `cameras detected: ${cams.length}`);
      } catch (e) {
        addTest('enumerateDevices() videoinput', false, String(e));
      }
      const inIframe = window.top !== window.self;
      addTest('Embedded in iframe', inIframe !== false, inIframe ? 'yes' : 'no');
      addTest('Export support (toDataURL)', (()=>{try{const c=document.createElement('canvas');c.width=2;c.height=2;return typeof c.toDataURL==='function';}catch(e){return false;}})(), 'canvas.toDataURL available');
      if (!isSecureOrLocalhost() || inIframe) {
        showBanner('warn', 'Camera may be blocked by insecure context or iframe policies. Use <code class="k">https://</code>/<code class="k">localhost</code> and <code class="k">allow="camera; microphone"</code>.');
      }
    })();

    // Auto-start if permission was already granted
    (async function autoStart(){
      try {
        if (navigator.permissions?.query) {
          const st = await navigator.permissions.query({ name: 'camera' });
          if (st.state === 'granted') start();
        }
      } catch {}
      requestAnimationFrame(resizeCanvases);
    })();
  </script>
</body>
</html>

